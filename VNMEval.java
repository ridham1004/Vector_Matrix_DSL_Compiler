/* Generated By:JavaCC: Do not edit this line. VNMEval.java Version 7.0.9 */
import java.io.PrintStream;

public class VNMEval implements VNMVisitor {

  // Helper to visit children recursively
  public Object defaultVisit(SimpleNode node, Object data) throws Exception {
    node.childrenAccept(this, data);
    return null;
  }

  public Object visit(SimpleNode node, Object data) throws Exception {
    return defaultVisit(node, data);
  }

  // ==========================================
  // 1. Literals
  // ==========================================

  public Object visit(ASTnumber node, Object data) throws Exception {
    // The value is stored in the node by the parser (see idnum/number in VNM.jjt)
    return node.jjtGetValue(); 
  }

  public Object visit(ASTstring node, Object data) throws Exception {
    return node.jjtGetValue();
  }

  public Object visit(ASTTRUE node, Object data) throws Exception {
    return Boolean.TRUE;
  }

  public Object visit(ASTFALSE node, Object data) throws Exception {
    return Boolean.FALSE;
  }

  public Object visit(ASTidbool node, Object data) throws Exception {
      // For this part, we treat idbool as a simple identifier if used as a literal in assignment,
      // but if it has a value attached (from parser), return it.
      // If your parser attaches values to IDBOOL tokens, we return that here.
      // Otherwise, for #1/#0 literals, ASTTRUE/ASTFALSE are used.
      return node.jjtGetValue(); 
  }

  // ==========================================
  // 2. Print Statements
  // ==========================================

  public Object visit(ASTPrint node, Object data) throws Exception {
    int children = node.jjtGetNumChildren();
    for (int i = 0; i < children; i++) {
      // Accept child to get its value (String, Integer, Boolean)
      Object val = node.jjtGetChild(i).jjtAccept(this, data);
      System.out.print(val);
    }
    return null;
  }

  public Object visit(ASTPrint_ln node, Object data) throws Exception {
    int children = node.jjtGetNumChildren();
    for (int i = 0; i < children; i++) {
      Object val = node.jjtGetChild(i).jjtAccept(this, data);
      System.out.print(val);
    }
    System.out.println(); // Add newline at the end
    return null;
  }

  // ==========================================
  // 3. Arithmetic Operations
  // ==========================================

  public Object visit(ASTsum node, Object data) throws Exception {
    // ASTsum can have multiple children.
    // The grammar structure implies:
    // Child 0: The first term (evaluated directly)
    // Child 1..N: ASTpos or ASTneg nodes (which wrap the subsequent terms)
    
    int numChildren = node.jjtGetNumChildren();
    int sum = 0;

    for (int i = 0; i < numChildren; i++) {
      Object val = node.jjtGetChild(i).jjtAccept(this, data);
      if (val instanceof Integer) {
        sum += (Integer) val;
      } else {
        throw new Exception("Runtime Error: Arithmetic operation on non-integer.");
      }
    }
    return sum;
  }

  public Object visit(ASTneg node, Object data) throws Exception {
    // Unary minus (or part of a sum). Returns the negative of its child.
    Object val = node.jjtGetChild(0).jjtAccept(this, data);
    if (val instanceof Integer) {
      return -((Integer) val);
    }
    throw new Exception("Runtime Error: Type mismatch in negation.");
  }

  public Object visit(ASTpos node, Object data) throws Exception {
    // Unary plus. Returns the child value as is.
    Object val = node.jjtGetChild(0).jjtAccept(this, data);
    if (val instanceof Integer) {
      return (Integer) val;
    }
    throw new Exception("Runtime Error: Type mismatch in positive.");
  }

  public Object visit(ASTmul node, Object data) throws Exception {
    Object v1 = node.jjtGetChild(0).jjtAccept(this, data);
    Object v2 = node.jjtGetChild(1).jjtAccept(this, data);
    return (Integer) v1 * (Integer) v2;
  }

  public Object visit(ASTdiv node, Object data) throws Exception {
    Object v1 = node.jjtGetChild(0).jjtAccept(this, data);
    Object v2 = node.jjtGetChild(1).jjtAccept(this, data);
    if ((Integer)v2 == 0) throw new Exception("Runtime Error: Division by zero.");
    return (Integer) v1 / (Integer) v2;
  }

  public Object visit(ASTmod node, Object data) throws Exception {
    Object v1 = node.jjtGetChild(0).jjtAccept(this, data);
    Object v2 = node.jjtGetChild(1).jjtAccept(this, data);
    if ((Integer)v2 == 0) throw new Exception("Runtime Error: Modulo by zero.");
    return (Integer) v1 % (Integer) v2;
  }

  // ==========================================
  // 4. Comparisons
  // ==========================================

  public Object visit(ASTcomparison node, Object data) throws Exception {
    // Structure: Expression Comparator Expression
    // Child 0: Left Expression
    // Child 1: Comparator Node (ASTle, ASTeq, etc.)
    // Child 2: Right Expression

    Object leftVal = node.jjtGetChild(0).jjtAccept(this, data);
    Object rightVal = node.jjtGetChild(2).jjtAccept(this, data);
    Node comparator = node.jjtGetChild(1);

    if (leftVal instanceof Integer && rightVal instanceof Integer) {
      int l = (Integer) leftVal;
      int r = (Integer) rightVal;

      if (comparator instanceof ASTle) return l < r;
      if (comparator instanceof ASTleq) return l <= r;
      if (comparator instanceof ASTgre) return l > r;
      if (comparator instanceof ASTgeq) return l >= r;
      if (comparator instanceof ASTeq) return l == r;
      if (comparator instanceof ASTneq) return l != r;
    }
    
    throw new Exception("Runtime Error: Invalid comparison operation.");
  }

  // ==========================================
  // 5. Boolean Logic (Conditions)
  // ==========================================

  public Object visit(ASTnot node, Object data) throws Exception {
    Object val = node.jjtGetChild(0).jjtAccept(this, data);
    if (val instanceof Boolean) {
      return !((Boolean) val);
    }
    throw new Exception("Runtime Error: '!' operator requires boolean operand.");
  }

  public Object visit(ASTand node, Object data) throws Exception {
    int children = node.jjtGetNumChildren();
    for (int i = 0; i < children; i++) {
      Object val = node.jjtGetChild(i).jjtAccept(this, data);
      if (!(val instanceof Boolean)) throw new Exception("Runtime Error: '&' requires boolean operands.");
      if (!((Boolean) val)) return false; // Short-circuit
    }
    return true;
  }

  public Object visit(ASTor node, Object data) throws Exception {
    int children = node.jjtGetNumChildren();
    for (int i = 0; i < children; i++) {
      Object val = node.jjtGetChild(i).jjtAccept(this, data);
      if (!(val instanceof Boolean)) throw new Exception("Runtime Error: '|' requires boolean operands.");
      if ((Boolean) val) return true; // Short-circuit
    }
    return false;
  }

  // ==========================================
  // 6. If Statements
  // ==========================================

  public Object visit(ASTIf node, Object data) throws Exception {
    // Child 0: Condition
    // Child 1: Then Clause (Body)
    // Child 2: Else Clause (Can be ASTIf, ASTclause, or ASTNULL)
    
    Object condition = node.jjtGetChild(0).jjtAccept(this, data);
    
    if (!(condition instanceof Boolean)) {
      throw new Exception("Runtime Error: If-statement condition must be boolean.");
    }

    if ((Boolean) condition) {
      return node.jjtGetChild(1).jjtAccept(this, data);
    } else {
      // Execute the else part (which might be an "elif" (nested If), "else", or NULL)
      return node.jjtGetChild(2).jjtAccept(this, data);
    }
  }

  public Object visit(ASTNULL node, Object data) throws Exception {
    // Represents an empty else/elif block. Do nothing.
    return null;
  }

  // ==========================================
  // Structure Helpers (Pass-through)
  // ==========================================

  public Object visit(ASTbody node, Object data) throws Exception {
    return defaultVisit(node, data);
  }
  
  public Object visit(ASTclause node, Object data) throws Exception {
    return defaultVisit(node, data);
  }

  // ==========================================
  // Unimplemented / Default nodes
  // ==========================================
  // These use defaultVisit, which just visits children. 
  // Assignments and variable declarations are not required for Part 4 evaluation per the specs.

  public Object visit(ASTvar_decl node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTfn_decl node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTident_list node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTfn_call node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTboolean_call node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTexp_list node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTcondition_list node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTReturn node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTAssign node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTFor node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTWhile node, Object data) throws Exception { return defaultVisit(node, data); }
  
  // Comparators (visited by ASTcomparison, but defined here to satisfy interface)
  public Object visit(ASTle node, Object data) throws Exception { return null; }
  public Object visit(ASTleq node, Object data) throws Exception { return null; }
  public Object visit(ASTgre node, Object data) throws Exception { return null; }
  public Object visit(ASTgeq node, Object data) throws Exception { return null; }
  public Object visit(ASTeq node, Object data) throws Exception { return null; }
  public Object visit(ASTneq node, Object data) throws Exception { return null; }
  public Object visit(ASTin node, Object data) throws Exception { return null; }
  public Object visit(ASTnotin node, Object data) throws Exception { return null; }
  
  public Object visit(ASTvec_const node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTidvec node, Object data) throws Exception { return defaultVisit(node, data); }
  public Object visit(ASTidnum node, Object data) throws Exception { return defaultVisit(node, data); }
}
/* JavaCC - OriginalChecksum=22d58c5389ead436110ed9c53d7f4358 (do not edit this line) */
